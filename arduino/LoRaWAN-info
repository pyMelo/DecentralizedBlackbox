/**
 * This code will send a two-byte LoRaWAN message every 15 minutes. 
 * The first byte is a simple 8-bit counter.
 * The second byte is a randomly generated number between 0 and 255.
 *
 * If your NVS partition does not have stored TTN / LoRaWAN provisioning
 * information in it yet, you will be prompted for them on the serial port 
 * and they will be stored for subsequent use.
 *
 * See https://github.com/ropg/LoRaWAN_ESP32
*/

#define MINIMUM_DELAY 900  // Delay tra due trasmissioni consecutive (15 minuti)

#include <RadioLib.h>
#include <LoRaWAN_ESP32.h>

// Radio module configuration (for Heltec V3)
SX1262 radio = new Module(8, 14, 12, 13);

LoRaWANNode* node;
RTC_DATA_ATTR uint8_t count = 0;  // Variabile che viene mantenuta dopo deep sleep


#include <nvs_flash.h>

void resetLoRaWANKeys() {
    Serial.println("üö® Resetting LoRaWAN keys in NVS Flash...");
    nvs_flash_erase();  // Clears all stored data in NVS Flash
    nvs_flash_init();   // Re-initializes the flash memory
}
void setup() {
    Serial.begin(115200);

    //resetLoRaWANKeys(); per resettare i dati del dispositivo

    delay(1000);

    // Valore fittizio generato casualmente invece della temperatura reale
    uint8_t fakeData = random(0, 256);
    Serial.printf("Generated fake data: %d\n", fakeData);

    // Inizializza il modulo LoRa
    Serial.println("Radio init");
    int16_t state = radio.begin();
    if (state != RADIOLIB_ERR_NONE) {
        Serial.println("‚ùå Radio initialization failed. Retrying later.");
        goToSleep();
    }

    node = persist.manage(&radio);
    if (!node->isActivated()) {
        Serial.println("‚ùå Could not join network. Retrying later.");
        goToSleep();
    }

    // Configura il Duty Cycle per rispettare la Fair Use Policy di TTN
    node->setDutyCycle(true, 1250);

    // Creazione del pacchetto dati fittizio
    uint8_t uplinkData[2];
    uplinkData[0] = count++;       // Incrementa il contatore
    uplinkData[1] = fakeData;      // Dato fittizio casuale

    uint8_t downlinkData[256];
    size_t lenDown = sizeof(downlinkData);

    state = node->sendReceive(uplinkData, sizeof(uplinkData), 1, downlinkData, &lenDown);

    if (state == RADIOLIB_ERR_NONE) {
        Serial.println("‚úÖ Message sent successfully, no downlink received.");
    } else if (state > 0) {
        Serial.println("‚úÖ Message sent successfully, downlink received.");
    } else {
        Serial.printf("‚ùå sendReceive returned error %d, retrying later.\n", state);
    }

    goToSleep();  // Manda il dispositivo in deep sleep fino alla prossima trasmissione
}

void loop() {
    // Mai chiamata. Il dispositivo entra in deep sleep dopo ogni trasmissione.
}

void goToSleep() {
    Serial.println("üí§ Going to deep sleep now...");
    //IMPORTANTE DA SALVARE LA SESSIONE
    persist.saveSession(node);  // Salva la sessione LoRaWAN

    // Calcola il ritardo minimo tra due trasmissioni, rispettando i limiti di duty cycle
    uint32_t interval = node->timeUntilUplink();
    uint32_t delayMs = max(interval, (uint32_t)MINIMUM_DELAY * 1000);
    
    Serial.printf("‚è≥ Next TX in %i s\n", delayMs / 1000);
    delay(100);  // Per permettere alla seriale di stampare i log prima dello sleep

    // Imposta il timer per il risveglio automatico dopo il tempo specificato
    esp_sleep_enable_timer_wakeup((int64_t)delayMs * 1000);

    // Entra in modalit√† deep sleep
    esp_deep_sleep_start();
}
