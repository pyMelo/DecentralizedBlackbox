#define MINIMUM_DELAY 900 // Delay between two consecutive transmissions (15 minutes)

#include <RadioLib.h>
#include <LoRaWAN_ESP32.h>
#include <DHT11.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>

SX1262 radio = new Module(8, 14, 12, 13);
LoRaWANNode* node;
RTC_DATA_ATTR uint8_t count = 0;

#define DHT11_PIN 7
#define BUTTON_PIN 0  // PRG button on Heltec ESP32 (GPIO 0)
DHT11 dht11(DHT11_PIN);
Adafruit_MPU6050 mpu;

void createSensorBlock(bool encrypted, uint8_t sensorType, uint32_t payload, uint8_t* blockBuffer) {
    uint64_t block = 0;
    block |= ((uint64_t)(encrypted ? 1 : 0)) << 39;
    block |= ((uint64_t)(sensorType & 0x0F)) << 32;
    block |= payload;
    for (int i = 0; i < 5; i++) {
        blockBuffer[i] = (uint8_t)((block >> ((4 - i) * 8)) & 0xFF);
    }
}

void setup() {
    Serial.begin(115200);
    delay(1000);

    pinMode(BUTTON_PIN, INPUT_PULLUP);  // Configure PRG button (GPIO 0)

    Serial.println("Initializing sensors...");
    persist.wipe();
    Wire.begin();
    if (!mpu.begin()) {
        Serial.println("Failed to find MPU6050 chip");
        while (1) { delay(10); }
    }
    mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
    mpu.setGyroRange(MPU6050_RANGE_500_DEG);
    mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

    Serial.println("Initializing LoRa module...");
    int16_t state = radio.begin();
    if (state != RADIOLIB_ERR_NONE) {
        Serial.println("âŒ LoRa initialization failed.");
        return;
    }

    node = persist.manage(&radio);
    if (node->isActivated()) {
        Serial.println("âœ… Device is already activated. Skipping join.");
    } else {
        Serial.println("ðŸŒ Joining LoRaWAN network...");
        uint64_t joinEUI = 0x4A444EABA0040405;
        uint64_t devEUI = 0x70B3D57ED006E906;
        uint8_t appKey[] = {0xC9, 0xB1, 0xD7, 0x70, 0xF7, 0x05, 0xBC, 0xB1, 
                            0x04, 0x91, 0x56, 0xCB, 0xD3, 0x40, 0x54, 0x35};
        int16_t joinResult = node->beginOTAA(joinEUI, devEUI, appKey, appKey);
        if (joinResult != RADIOLIB_ERR_NONE) {
            Serial.printf("âŒ Join failed with error %d\n", joinResult);
        } else {
            Serial.println("âœ… Successfully joined LoRaWAN network!");
        }
    }

    node->setDutyCycle(true, 1250);
}

void sendLoRaData() {
    int temperature = 0, humidity = 0;
    dht11.readTemperatureHumidity(temperature, humidity);

    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    float Accel = sqrt(a.acceleration.x * a.acceleration.x +
                        a.acceleration.y * a.acceleration.y +
                        a.acceleration.z * a.acceleration.z);

    uint8_t dhtBlock[5];
    createSensorBlock(false, 0x1, (((uint16_t)temperature) << 16) | ((uint16_t)humidity), dhtBlock);

    uint8_t accelBlock[5];
    createSensorBlock(true, 0x2, (uint32_t)(Accel * 100), accelBlock);

    uint8_t gyroBlock[5];
    createSensorBlock(false, 0x3, (((uint16_t)(g.gyro.x * 100)) << 16) | ((uint16_t)(g.gyro.y * 100)), gyroBlock);

    uint8_t payload[15];
    memcpy(payload, dhtBlock, 5);
    memcpy(payload + 5, accelBlock, 5);
    memcpy(payload + 10, gyroBlock, 5);

    Serial.print("Payload: ");
    for (int i = 0; i < 15; i++) {
        Serial.printf("%02X ", payload[i]);
    }
    Serial.println();

    uint8_t downlinkData[256];
    size_t lenDown = sizeof(downlinkData);

    int state = node->sendReceive(payload, sizeof(payload), 1, downlinkData, &lenDown);

    if (state == RADIOLIB_ERR_NONE) {
        Serial.println("âœ… Message sent successfully, no downlink received.");
    } else if (state > 0) {
        Serial.printf("âœ… Message sent successfully, downlink received (%d bytes).\n", lenDown);
        Serial.print("ðŸ“¥ Downlink Received: ");
        for (size_t i = 0; i < lenDown; i++) {
            Serial.printf("%02X ", downlinkData[i]);
        }
        Serial.println();
    } else {
        Serial.printf("âŒ sendReceive returned error %d, retrying later.\n", state);
    }

    // Save the session but do not enter deep sleep
    persist.saveSession(node);
}

void loop() {
    static unsigned long lastSendTime = 0;
    unsigned long currentMillis = millis();

    // Send data every MINIMUM_DELAY seconds
    if (currentMillis - lastSendTime >= MINIMUM_DELAY * 1000) {
        lastSendTime = currentMillis;
        sendLoRaData();
    }

    // Check if the button is pressed (low signal due to pull-up)
    if (digitalRead(BUTTON_PIN) == LOW) {
        Serial.println("ðŸ”˜ Button pressed! Resending data...");
        sendLoRaData();

        // Debounce delay
        delay(500);
        while (digitalRead(BUTTON_PIN) == LOW);  // Wait for button release
    }

    delay(10); // Small delay to avoid unnecessary CPU usage
}
