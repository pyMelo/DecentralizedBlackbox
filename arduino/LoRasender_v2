#define MINIMUM_DELAY 900 // Delay tra due trasmissioni consecutive (15 minuti)

#include <RadioLib.h>
#include <LoRaWAN_ESP32.h>
#include <DHT11.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <Crypto.h>
#include <SHA256.h>
#include <AES.h>
#include <CTR.h>

SX1262 radio = new Module(8, 14, 12, 13);
LoRaWANNode* node;
RTC_DATA_ATTR uint8_t count = 0;
RTC_DATA_ATTR uint32_t message_counter = 0;

#define DHT11_PIN 7
#define BUTTON_PIN 0  
DHT11 dht11(DHT11_PIN);
Adafruit_MPU6050 mpu;
uint32_t devAddr = 0x268B2930;

// 🔑 Master Key e Daily Key
uint8_t master_key[32] = { 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22,
                            0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0x00,
                            0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22,
                            0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0x00 };
uint8_t nwsKey[] = { 0x8B, 0x47, 0x6D, 0x64, 0xAC, 0xD9, 0x12, 0x53, 0xCB, 0x77, 0x5A, 0xD2, 0x85, 0x76, 0x30, 0x3B };
uint8_t appsKey[] = { 0x30, 0x50, 0x40, 0xC1, 0x1E, 0xF4, 0xE0, 0xA0, 0x93, 0x19, 0xAF, 0x36, 0xCE, 0x02, 0xB2, 0xF7 };

const char vehicle_id[] = "YOUR_VEHICLE_ID";
uint8_t daily_key[32];

const uint32_t MANUAL_DATE = 20250306;

// 🔹 Genera la Daily Key basata sulla data manuale
void generateDailyKey() {
    SHA256 sha256;
    size_t vehicle_id_len = strlen(vehicle_id);
    
    // Limitiamo la lunghezza a 8 caratteri per evitare overflow
    if (vehicle_id_len > 8) vehicle_id_len = 8;
    
    uint8_t input[32 + vehicle_id_len + 4]; // 32 bytes for master_key, dynamic length for vehicle_id, 4 bytes for date
    
    memcpy(input, master_key, 32);
    memcpy(input + 32, vehicle_id, vehicle_id_len);
    memcpy(input + 32 + vehicle_id_len, &MANUAL_DATE, 4);
    
    sha256.reset();
    sha256.update(input, sizeof(input));
    sha256.finalize(daily_key, 32);
    
    // Debug: print generated Daily Key
    Serial.print("🔑 Daily Key: ");
    for (int i = 0; i < 32; i++) {
        Serial.printf("%02X", daily_key[i]);
    }
    Serial.println();
    
    message_counter = 0;
}

// 🔹 Cifratura AES-CTR con IV progressivo
void encryptAESCTR(uint8_t* data, size_t length) {
    uint8_t counter[16] = {0};
    memcpy(counter, &message_counter, sizeof(message_counter));

    // Debug: print the IV (counter)
    Serial.print("🟢 IV: ");
    for (int i = 0; i < 16; i++) {
        Serial.printf("%02X ", counter[i]);
    }
    Serial.println();

    AES256 aes;
    CTR<AES256> aesCtr;
    aesCtr.setKey(daily_key, sizeof(daily_key));
    aesCtr.setIV(counter, 16);
    
    // Debug: print data before encryption
    Serial.print("🔄 Data Before Encryption: ");
    for (size_t i = 0; i < length; i++) {
        Serial.printf("%02X ", data[i]);
    }
    Serial.println();
    
    aesCtr.encrypt(data, data, length);

    // Debug: print data after encryption
    Serial.print("🔒 Data After Encryption: ");
    for (size_t i = 0; i < length; i++) {
        Serial.printf("%02X ", data[i]);
    }
    Serial.println();
    
    message_counter++;
}

// 🔹 Creazione del payload con la nuova struttura
// NOTE: To accommodate the full encrypted block, we now use a 20-byte payload.
void createPayload(uint8_t* payload, uint32_t timestamp, int temperature, int humidity, 
                   float accel, float gyro_x, float gyro_y, float gyro_z) {
    // Bit 0 -> dati non crittografati
    payload[0] = 0b00000000; 

    // Temperatura (4 bit tipo, 16 bit valore)
    payload[1] = 0x01;  
    payload[2] = (temperature >> 8) & 0xFF;
    payload[3] = temperature & 0xFF;

    // Giroscopio (4 bit tipo, 24 bit valore)
    payload[4] = 0x03;  
    payload[5] = ((int16_t)(gyro_x * 100) >> 8) & 0xFF;
    payload[6] = (int16_t)(gyro_x * 100) & 0xFF;
    payload[7] = ((int16_t)(gyro_y * 100) >> 8) & 0xFF;
    payload[8] = (int16_t)(gyro_y * 100) & 0xFF;
    payload[9] = ((int16_t)(gyro_z * 100) >> 8) & 0xFF;
    payload[10] = (int16_t)(gyro_z * 100) & 0xFF;

    // Timestamp (32 bit)
    memcpy(&payload[11], &timestamp, 4);

    // Bit 1 -> dati crittografati
    payload[15] = 0b10000000; 

    // Accelerometro (4 bit tipo, 8 bit valore)
    payload[16] = 0x02;  
    payload[17] = (uint8_t)(accel * 100);  

    // The encrypted section is 5 bytes long: bytes 15 to 19.
    // Debug: print the payload before encryption.
    Serial.print("🔹 Unencrypted Payload: ");
    for (int i = 0; i < 20; i++) {
        Serial.printf("%02X ", payload[i]);
    }
    Serial.println();
    
    // Encrypt from payload[15] to payload[19] (5 bytes)
    encryptAESCTR(&payload[15], 5);
    
    // Debug: print the final payload after encryption.
    Serial.print("🔹 Final Payload: ");
    for (int i = 0; i < 20; i++) {
        Serial.printf("%02X ", payload[i]);
    }
    Serial.println();
}

// 🔹 Invio dei dati con struttura aggiornata
void sendLoRaData() {
    int temperature = 0, humidity = 0;
    dht11.readTemperatureHumidity(temperature, humidity);
    
    // Debug: print sensor data (Temperature & Humidity)
    Serial.printf("🌡 Temperature: %d, Humidity: %d\n", temperature, humidity);

    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    uint32_t timestamp = (uint32_t)time(nullptr);
    float Accel = sqrt(a.acceleration.x * a.acceleration.x +
                        a.acceleration.y * a.acceleration.y +
                        a.acceleration.z * a.acceleration.z);
    
    // Debug: print Gyro and Accelerometer data
    Serial.printf("🌀 Gyro: x=%.2f, y=%.2f, z=%.2f\n", g.gyro.x, g.gyro.y, g.gyro.z);
    Serial.printf("🔋 Accelerometer: %.2f\n", Accel);

    // Increase payload size to 20 bytes
    uint8_t payload[20] = {0};  
    createPayload(payload, timestamp, temperature, humidity, Accel, g.gyro.x, g.gyro.y, g.gyro.z);

    Serial.print("📡 Sending Payload: ");
    for (int i = 0; i < 20; i++) {
        Serial.printf("%02X ", payload[i]);
    }
    Serial.println();

    uint8_t downlinkData[256];
    size_t lenDown = sizeof(downlinkData);

    int state = node->sendReceive(payload, sizeof(payload), 1, downlinkData, &lenDown);
    if (state == RADIOLIB_ERR_NONE) {
        Serial.println("✅ Message sent successfully, no downlink received.");
    } else if (state > 0) {
        Serial.printf("✅ Message sent successfully, downlink received (%d bytes).\n", lenDown);
    } else {
        Serial.printf("❌ sendReceive returned error %d, retrying later.\n", state);
    }

    persist.saveSession(node);    
    node = persist.manage(&radio);
    if (node->isActivated()) {
        Serial.println("✅ Device already activated. Using persisted session.");
    } else {
        state = node->beginABP(devAddr, NULL, NULL, nwsKey, appsKey);
        if (state != RADIOLIB_ERR_NONE) {
            Serial.printf("❌ ABP activation failed with error %d\n", state);
        } else {
            Serial.println("✅ Device activated using ABP.");
        }
    }
}

void setup() {
    Serial.begin(115200);
    delay(1000);

    pinMode(BUTTON_PIN, INPUT_PULLUP);  // Configura il pulsante PRG (GPIO 0)

    Serial.println("Initializing sensors...");
    Wire.begin();
    if (!mpu.begin()) {
        Serial.println("❌ Failed to find MPU6050 chip");
        while (1) { delay(10); }
    }
    mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
    mpu.setGyroRange(MPU6050_RANGE_500_DEG);
    mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

    Serial.println("Initializing LoRa module...");
    int16_t state = radio.begin();
    if (state != RADIOLIB_ERR_NONE) {
        Serial.println("❌ LoRa initialization failed.");
        return;
    }

    node = persist.manage(&radio);
    node->setDatarate(3);
    node->setADR(false);

    if (node->isActivated()) {
        Serial.println("✅ Device already activated. Using persisted session.");
    } else {
        Serial.println("Using ABP state");
        state = node->beginABP(devAddr, NULL, NULL, nwsKey, appsKey);
        if (state != RADIOLIB_ERR_NONE) {
            Serial.printf("❌ ABP activation failed with error %d\n", state);
        } else {
            Serial.println("✅ Device activated using ABP.");
        }
    }

    node->setDutyCycle(true, 1250);

    // 🔹 Genera la Daily Key all'avvio
    Serial.println("Generating Daily Key...");
    generateDailyKey();
    Serial.println("✅ Daily Key generated.");

    // 🔹 Inizializza il contatore del messaggio per AES-CTR
    Serial.println("Resetting message counter...");
    message_counter = 0;
    Serial.println("✅ Message counter reset.");
}

void loop() {
    static unsigned long lastSendTime = 0;
    unsigned long currentMillis = millis();

    if (currentMillis - lastSendTime >= MINIMUM_DELAY * 1000) {
        lastSendTime = currentMillis;
        sendLoRaData();
    }

    if (digitalRead(BUTTON_PIN) == LOW) {
        sendLoRaData();
        delay(500);
        while (digitalRead(BUTTON_PIN) == LOW);  // Attendi il rilascio del pulsante
    }

    delay(10); // Piccolo delay per ridurre l'uso della CPU
}
